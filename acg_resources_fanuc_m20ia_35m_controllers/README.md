# acg_resources_fanuc_m20ia_35m_controllers

This package contains the controllers developed for the Fanuc M-20iA/35M robot. The controllers are based on the ros2_control framework and they can be used on simulated hardware on the Ignition Gazebo simulator. The controllers are:
- `fanuc_m20ia_35m_PID_controller`: a PID controller for the Fanuc M-20iA/35M robot based on independent joint control. It is a `JointTrajectoryController` that accepts position, velocity and effort references in the joint space. For further details on the controller, please refer to the package `joint_trajectory_controller`;
- `fanuc_m20ia_35m_task_space_controller`: a task space controller for the Fanuc M-20iA/35M robot based on kinematic inversion. It is a `TaskSpaceTrajectoryController` that accepts pose and velocity references in the task space. For further details on the controller, please refer to the package `task_space_trajectory_controller` (also provided by us).

## Installing the dependencies
 
In order to install the needed dependencies run the command

```bash
rosdep install --from-paths src --ignore-src -r -y
```
    
inside the project's root folder

## Package contents
The package contins the configuration files for the controllers as well as the launch files to run some demos using the controllers. The provided configuration files are:
- `ros2_controllers.yaml`: configuration file for the `controller_manager` node, as well as for the controllers;
- `moveit_controllers.yaml`: configuration file for the moveit `simple_controller_manager` bridge;
- `task_space_control_demo.rviz`: RViz configuration file for the task space controller demo;

## Launch files
The provided launch files are:
- `independent_joint_control_demo.launch.py`: this is a demonstration of the independent joint control PID controller with simulated hardware on Gazebo and RViz's MotionPlanning plugin for planning and execution;
- `task_space_control_demo.launch.py`: this is a demonstration of the task space control controller with simulated hardware on Gazebo and RViz's MotionPlanning plugin for planning and execution;
- `gazebo_ros2_control_demo.launch.py`: this is a more general-purpose launch file that can be used to run the controllers on simulated hardware on Gazebo. It can be used to run the controllers with external reference generators, such as ros2 topic pub, or with RViz's MotionPlanning plugin. It can also be used to run the controllers with different command interfaces, such as `effort`, `velocity` or `position`. The launch file accepts the following arguments:
    - `controller_list` (default: `fanuc_m20ia_35m_PID_controller`): list of controllers to be loaded separated by a space. By default `joint_state_broadcaster` controller is always loaded;
    - `command_interface` (default: `effort`): command interface to be loaded on the simulated hardware. It can be `effort`, `velocity` or `position`;
    - `gui` (default: `true`): whether to launch the RViz GUI or not;

Below we provide further details on the launch files.

### Trajectory tracking with independent joint control on simulated hardware with MoveIt! planning system
This demo shows how to use the independent joint control PID controller with simulated hardware on Gazebo and RViz's MotionPlanning plugin for planning and execution. This demo uses the ign_ros2_control/IgnitionSystem to simulate the robot on Gazebo with `effort` command interfaces. The `controller_manager` node is launched by Gazebo thanks to the `ign_ros2_control::IgnitionROS2ControlPlugin` plugin.

In order to execute this demo, run:

  ```bash
  ros2 launch acg_resources_fanuc_m20ia_35m_controllers independent_joint_control_demo.launch.py
  ```

Both Gazebo and RViz will be launched. Trajectories can be planned and executed using RViz's MotionPlanning plugin. The trajectories tracking is handled by the `fanuc_m20ia_35m_PID_controller` joint trajectory controller on the simulated hardware.

For the execution of custom trajectories with this controller, please refer to the package `fanuc_m20ia_35m_planning_demo`.

### Trajectory tracking with independent joint control on simulated hardware with external reference generator
This demo is similar to the previous one, with the only differences that RViz's MotionPlanning plugin is not launched and the references can be generated by an external reference generator, such as ros2 topic pub. In order to execute this demo, run:

  ```bash
  ros2 launch acg_resources_fanuc_m20ia_35m_controllers gazebo_ros2_control_demo.launch.py controller_list:='fanuc_m20ia_35m_PID_controller' command_interface:='effort'
  ```

Reference joint trajectories can be sent to the `fanuc_m20ia_35m_PID_controller` via the action interface `/fanuc_m20ia_35m_PID_controller/follow_joint_trajectory` or via the topic interface `/fanuc_m20ia_35m_PID_controller/joint_trajectory`. The following command shows how to send a reference trajectory to the controller via the topic interface:

```bash
ros2 topic pub -1 /fanuc_m20ia_35m_PID_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory "{\
  header: {\
    stamp: {sec: 0, nanosec: 0},\
    frame_id: world\
  },\
  joint_names: [fanuc_m20ia_35m_joint_1, fanuc_m20ia_35m_joint_2, fanuc_m20ia_35m_joint_3, fanuc_m20ia_35m_joint_4, fanuc_m20ia_35m_joint_5, fanuc_m20ia_35m_joint_6],\
  points: [\
    {\
      positions: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\
      velocities: [],\
      accelerations: [],\
      effort:[],\
      time_from_start: {sec: 0, nanosec: 0}\
    },\
    {\
      positions: [-3.14, 1.57, 1.57, 0.0, 1.047, 0.0],\
      velocities: [],\
      accelerations: [],\
      effort:[],\
      time_from_start: {sec: 2, nanosec: 0}\
    }\
  ]\
}"
```

### Task space pose regulation on simulated hardware with custom RViz reference generator
This demo shows how to use the task space control controller with simulated hardware on Gazebo and a custom task space reference generator. The hardware configuration is the same as the one used in the previous demos, except for the fact that in this case `velocity` command interfaces are loaded instead of `effort` command interfaces. That is because the `TaskSpaceTrajectoryController` assumes that the robot is controlled in velocity. 

In this case the references are generated by a custom node called `reference_generator` in the package `task_space_trajectory_controller`. The `reference_generator` node creates an interactive marker that can be moved by the user on RViz and publishes the references on the topic `/fanuc_m20ia_35m_arm_task_space_controller/command`. 

In order to execute this demo, run:

  ```bash
  ros2 launch acg_resources_fanuc_m20ia_35m_controllers task_space_control_demo.launch.py
  ```
Both Gazebo and RViz will be launched. Task space pose reference can be changed with the interactive marker in RViz. The regulation of the end-effector on the reference pose is handled by the `fanuc_m20ia_35m_task_space_controller` joint trajectory controller on the simulated hardware.

For the execution of custom trajectories with this controller, please refer to the package `fanuc_m20ia_35m_planning_demo`.

### Trajectory tracking with task space control on simulated hardware with external reference generator
This demo is similar to the previous one, with the only difference that the reference generator node is not launched and the references can be generated by an external reference generator, such as ros2 topic pub. In order to execute this demo, run:

  ```bash
  ros2 launch acg_resources_fanuc_m20ia_35m_controllers gazebo_ros2_control_demo.launch.py controller_list:='fanuc_m20ia_35m_task_space_controller' command_interface:='velocity'
  ```
    
Reference task space trajectories can be sent to the `fanuc_m20ia_35m_task_space_controller` via the action interface `/fanuc_m20ia_35m_task_space_controller/follow_cartesian_trajectory`. The following command shows how to send a reference trajectory to the controller via the action interface:

```bash
ros2 action send_goal /fanuc_m20ia_35m_task_space_controller/follow_cartesian_trajectory cartesian_control_msgs/action/FollowCartesianTrajectory "{\
  trajectory:{
    header: {\
      stamp: {\
        sec: 0,\
        nanosec: 0\
      },\
      frame_id: 'world'\
    },\
    tracked_frame: 'fanuc_m20ia_35m_drilling_tool',\
    points: [\
      {\
        point: {\
          pose: {\
            position: {\
              x: 1.4098,\
              y: 0.0,\
              z: 1.8311\
            },\
            orientation: {\
              x: 0.707,\
              y: 0.0,\
              z: 0.707,\
              w: 0.0\
            }\
          },\
          velocity: {\
            linear: {\
              x: 0.0,\
              y: 0.0,\
              z: 0.0\
            },\
            angular: {\
              x: 0.0,\
              y: 0.0,\
              z: 0.0\
            }\
          },\
        },\
        time_from_start: {sec: 3.0, nanosec: 0.0}\
      },\
      {\
        point: {\
          pose: {\
            position: {\
              x: 0.46954,\
              y: -1.0188,\
              z: 1.8311\
            },\
            orientation: {\
              x: 0.49378,\
              y: -0.506,\
              z: 0.49379,\
              w: 0.50614\
            }\
          },\
          velocity: {\
            linear: {\
              x: 0.0,\
              y: 0.0,\
              z: 0.0\
            },\
            angular: {\
              x: 0.0,\
              y: 0.0,\
              z: 0.0\
            }\
          },\
        },\
        time_from_start: {sec: 6.0, nanosec: 0.0}\
      },\
    ]\
  }\
}"
```

The `fanuc_m20ia_35m_task_space_controller` can also be used for regulating the end-effector on a given point via the topic interface `/fanuc_m20ia_35m_task_space_controller/command`. The following command shows how to send a reference point to the controller via the command topic:

```bash
ros2 topic pub -1 /fanuc_m20ia_35m_task_space_controller/command moveit_msgs/msg/CartesianTrajectoryPoint "{\
  point: {\
    pose: {\
      position: {\
        x: 0.5,\
        y: -1.0,\
        z: 1.80\
      },\
      orientation: {\
        x: 0.49381,\
        y: -0.50604,\
        z: 0.49382,\
        w: 0.50618\
      }\
    },\
    velocity: {\
      linear: {\
        x: 0.0,\
        y: 0.0,\
        z: 0.0\
      },\
      angular: {\
        x: 0.0,\
        y: 0.0,\
        z: 0.0\
      }\
    },\
  },\
  time_from_start: {sec: 0, nanosec: 0}\
}"
```

However, this is not the recommended way to use the `fanuc_m20ia_35m_task_space_controller` controller because it could lead to violent and uncontrolled movements of the robot. The controller is designed to be used with the action interface `/fanuc_m20ia_35m_task_space_controller/follow_cartesian_trajectory`. The topic interface `/fanuc_m20ia_35m_task_space_controller/command` is provided for debugging purposes only (see `task_space_control_demo.launch.py`).

## Some remarks on Ignition Gazebo
- Normally Gazebo should prevent the robot from falling under the effect of gravity when the simulation starts, until a controller is spawned. However, this is not the case when:
    - `effort` command interfaces are used. In this case, the robot falls under the effect of gravity and stops falling when the motion controller is loaded (this is a safety feature of `JointTrajectoryController` controllers). Differently from old versions of Gazebo, the controllers are only loaded if the simulator is not paused; this prevents loading the controllers before the action of gravity. To mitigate this issue, we run the controller spawner node for our PID controller before the samulation is sarted. By default the spawner remains on hold until the controller manager is instantiated, then it loads the controller. We raised the maximum waiting time of the spawner to 60 seconds to avoid issues;
    - Joint effort limits are too low in the URDF of the robot. This is the case of the panda robot (!). In this case even using `position` or `velocity` command interfaces, Gazebo is not able to prevent the robot from falling under the effect of gravity. By raising the maximum joint efforts on the URDF of the robot the issue is solved;
- The `create` command in `ros_gz_sim` package that we use to spawn the robot in Gazebo doesn't allow to set the initial joint positions of the robot. For further info see [this github issue](https://github.com/gazebosim/ros_gz/issues/291).

## Known issues
- If the `/robot_description` has already been written with a different robot description file (e.g. because a different launch file has been executed before), sometimes the `ign_ros2_control/IgnitionSystem` plugin will load the wrong hardware and, as a consequence, controllers will fail to load. Notice that if this happens when using `effort` command interfaces, the robot will fall under the effect of gravity. If this happens, please restart the ROS2 environment and launch the simulation again. 
- Even if we set the launch files to spawn the controllers as soon as the simulation starts, the controllers sometimes take an anomalous amount of time to load. When using `effort` command interfaces, this could lead to the robot falling under the effect of gravity. If this happens, please launch the simulation again. This could be artificially solved by passing a step reference to the controllers after the robot is fallen, but can lead to a violent and uncontrolled movement of the robot. 